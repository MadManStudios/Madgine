#version 300 es
#define readonly 
#define buffer uniform
#define std430 std140
precision mediump float;
precision highp int;

struct ScenePerApplication
{
    highp mat4 p;
    uint hasHDR;
    highp float ambientFactor;
    highp float diffuseFactor;
    highp float specularFactor;
};

struct DirectionalLight
{
    highp vec3 color;
    highp float _padding0;
    highp vec3 dir;
    highp float _padding1;
};

struct ShadowCaster
{
    highp mat4 reprojectionMatrix;
    int shadowSamples;
    highp float _padding0;
    highp float _padding1;
    highp float _padding2;
};

struct DirectionalShadowLight
{
    DirectionalLight light;
    ShadowCaster caster;
};

struct PointLight
{
    highp vec3 position;
    highp float _padding0;
    highp vec3 color;
    highp float _padding1;
    highp float constantFactor;
    highp float linearFactor;
    highp float squaredFactor;
    highp float _padding2;
};

struct PointShadowLight
{
    PointLight light;
    ShadowCaster caster;
};

struct ScenePerFrame
{
    int pointLightCount;
    highp float _padding0;
    highp float _padding1;
    highp float _padding2;
    DirectionalShadowLight light;
    PointShadowLight pointLights[2];
};

struct ScenePerObject
{
    highp float shininess;
    uint hasLight;
    uint hasTexture;
    uint hasDistanceField;
};

layout(std140) uniform buffer0
{
    layout(row_major) ScenePerApplication app;
} PerApplication;

layout(std140) uniform buffer1
{
    layout(row_major) ScenePerFrame frame;
} PerFrame;

layout(std140) uniform buffer2
{
    ScenePerObject object;
} PerObject;

uniform highp sampler2D texture4;
uniform highp sampler2DMS texture8;
uniform highp samplerCube texture9;
uniform highp samplerCube texture10;
uniform highp sampler2D texture5;

in highp vec4 out_var_COLOR;
in highp vec4 out_var_POSITION;
in highp vec3 out_var_NORMAL;
in highp vec2 out_var_TEXCOORD0;
in highp vec4 out_var_TEXCOORD1;
layout(location = 0) out highp vec4 out_var_SV_Target0;
layout(location = 1) out highp vec4 out_var_SV_Target1;

vec4 _88;

DirectionalShadowLight spvWorkaroundRowMajor(DirectionalShadowLight wrap) { return wrap; }
PointShadowLight spvWorkaroundRowMajor(PointShadowLight wrap) { return wrap; }

void main()
{
    highp vec3 _97 = normalize(out_var_NORMAL);
    bool _100 = PerObject.object.hasTexture != 0u;
    highp vec4 _132;
    if (_100)
    {
        highp vec4 _131;
        if (PerObject.object.hasDistanceField != 0u)
        {
            highp vec4 _112 = texture(texture4, out_var_TEXCOORD0);
            highp float _113 = _112.x;
            highp float _114 = _112.y;
            highp float _120 = max(min(_113, _114), min(max(_113, _114), _112.z)) - 0.5;
            _131 = out_var_COLOR * clamp((_120 / fwidth(_120)) + 0.5, 0.0, 1.0);
        }
        else
        {
            _131 = texture(texture4, out_var_TEXCOORD0) * out_var_COLOR;
        }
        _132 = _131;
    }
    else
    {
        _132 = out_var_COLOR;
    }
    highp vec4 _326;
    if (PerObject.object.hasLight != 0u)
    {
        highp vec3 _159 = out_var_TEXCOORD1.xyz / vec3(out_var_TEXCOORD1.w);
        highp vec3 _162 = _159;
        _162.y = _159.y * (-1.0);
        ivec2 _167 = ivec2(((_162.xy * 0.5) + vec2(0.5)) * 2048.0);
        highp float _169 = _159.z - 0.0005000000237487256526947021484375;
        highp float _171;
        _171 = 1.0;
        for (int _174 = 0; _174 < spvWorkaroundRowMajor(PerFrame.frame.light).caster.shadowSamples; )
        {
            _171 -= (float(_169 > texelFetch(texture8, _167, _174).x) / float(spvWorkaroundRowMajor(PerFrame.frame.light).caster.shadowSamples));
            _174++;
            continue;
        }
        highp vec3 _187 = -spvWorkaroundRowMajor(PerFrame.frame.light).light.dir;
        highp vec3 _193 = normalize(vec3(0.0, 0.0, -1.0));
        highp vec3 _202;
        _202 = (spvWorkaroundRowMajor(PerFrame.frame.light).light.color * PerApplication.app.ambientFactor) + (spvWorkaroundRowMajor(PerFrame.frame.light).light.color * ((PerApplication.app.diffuseFactor * _171) * max(dot(_97, _187), 0.0)));
        highp vec3 _203;
        for (int _205 = 0; _205 < PerFrame.frame.pointLightCount; _202 = _203, _205++)
        {
            if (_205 == 0)
            {
                highp vec3 _230 = out_var_POSITION.xyz / vec3(out_var_POSITION.w);
                highp vec3 _239 = (vec4(_230 - spvWorkaroundRowMajor(PerFrame.frame.pointLights[_205]).light.position, 0.0) * spvWorkaroundRowMajor(PerFrame.frame.pointLights[_205]).caster.reprojectionMatrix).xyz;
                highp vec3 _252 = spvWorkaroundRowMajor(PerFrame.frame.pointLights[_205]).light.position - _230;
                highp float _258 = length(_252);
                _203 = _202 + ((spvWorkaroundRowMajor(PerFrame.frame.pointLights[_205]).light.color * (((PerApplication.app.diffuseFactor * (1.0 - float((((length(_239) - 0.00999999977648258209228515625) * 0.0100010000169277191162109375) - 0.001000000047497451305389404296875) > texture(texture9, _239).x))) * 10.0) * max(dot(_97, normalize(_252)), 0.0))) * (1.0 / ((spvWorkaroundRowMajor(PerFrame.frame.pointLights[_205]).light.constantFactor + (spvWorkaroundRowMajor(PerFrame.frame.pointLights[_205]).light.linearFactor * _258)) + (spvWorkaroundRowMajor(PerFrame.frame.pointLights[_205]).light.squaredFactor * (_258 * _258)))));
            }
            else
            {
                highp vec3 _281 = out_var_POSITION.xyz / vec3(out_var_POSITION.w);
                highp vec3 _290 = (vec4(_281 - spvWorkaroundRowMajor(PerFrame.frame.pointLights[_205]).light.position, 0.0) * spvWorkaroundRowMajor(PerFrame.frame.pointLights[_205]).caster.reprojectionMatrix).xyz;
                highp vec3 _303 = spvWorkaroundRowMajor(PerFrame.frame.pointLights[_205]).light.position - _281;
                highp float _309 = length(_303);
                _203 = _202 + ((spvWorkaroundRowMajor(PerFrame.frame.pointLights[_205]).light.color * (((PerApplication.app.diffuseFactor * (1.0 - float((((length(_290) - 0.00999999977648258209228515625) * 0.0100010000169277191162109375) - 0.001000000047497451305389404296875) > texture(texture10, _290).x))) * 10.0) * max(dot(_97, normalize(_303)), 0.0))) * (1.0 / ((spvWorkaroundRowMajor(PerFrame.frame.pointLights[_205]).light.constantFactor + (spvWorkaroundRowMajor(PerFrame.frame.pointLights[_205]).light.linearFactor * _309)) + (spvWorkaroundRowMajor(PerFrame.frame.pointLights[_205]).light.squaredFactor * (_309 * _309)))));
            }
        }
        _326 = vec4((_202 * _132.xyz) + (spvWorkaroundRowMajor(PerFrame.frame.light).light.color * ((PerApplication.app.specularFactor * _171) * pow(max(dot(_193, -reflect(_187, _97)), 0.0), PerObject.object.shininess))), _132.w);
    }
    else
    {
        _326 = _132;
    }
    highp vec3 _334;
    if (_100)
    {
        _334 = texture(texture5, out_var_TEXCOORD0).xyz;
    }
    else
    {
        _334 = vec3(0.0);
    }
    highp vec4 _353;
    if (PerApplication.app.hasHDR != 0u)
    {
        highp vec4 _343 = vec4(_334, 1.0);
        highp vec4 _352;
        if (dot(_326.xyz, vec3(0.2125999927520751953125, 0.715200006961822509765625, 0.072200000286102294921875)) > 1.0)
        {
            highp vec3 _350 = _343.xyz + _326.xyz;
            _352 = vec4(_350.x, _350.y, _350.z, _343.w);
        }
        else
        {
            _352 = _343;
        }
        _353 = _352;
    }
    else
    {
        _353 = _88;
    }
    highp vec3 _355 = _326.xyz + _334;
    out_var_SV_Target0 = vec4(_355.x, _355.y, _355.z, _326.w);
    out_var_SV_Target1 = _353;
}


